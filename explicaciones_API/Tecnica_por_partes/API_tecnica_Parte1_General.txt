# API SteticSoft - Documentación Técnica Detallada

## 1. Introducción

Este documento proporciona una descripción técnica exhaustiva de la API de SteticSoft, un sistema de gestión integral para negocios de estética y belleza. El objetivo de esta API es ofrecer una interfaz programática robusta, segura y eficiente para interactuar con todos los módulos del sistema, permitiendo la automatización de procesos, la integración con otras herramientas y el desarrollo de nuevas funcionalidades.

Esta documentación está dirigida a desarrolladores, integradores y personal técnico que necesiten comprender en profundidad el funcionamiento interno de la API, sus capacidades, y cómo utilizarla correctamente.

**Funcionalidades Principales Cubiertas por la API:**

*   Gestión de autenticación y autorización de usuarios.
*   Administración de roles y permisos.
*   Gestión de perfiles de clientes, empleados y proveedores.
*   Manejo de inventario de productos y categorías.
*   Gestión de servicios, categorías de servicios y especialidades de empleados.
*   Programación y gestión de citas.
*   Registro de ventas y compras.
*   Gestión de abastecimientos de productos.
*   Manejo de novedades (excepciones de horario) para empleados.
*   Notificaciones por correo electrónico para eventos clave (ej. confirmación de citas, recuperación de contraseña).

## 2. Arquitectura General

La API de SteticSoft sigue una arquitectura RESTful, utilizando métodos HTTP estándar (GET, POST, PUT, DELETE) para la manipulación de recursos. Está construida sobre Node.js con el framework Express.js, lo que proporciona un entorno de ejecución rápido y escalable.

**Componentes Clave:**

*   **Servidor Web (Express.js):** Maneja las solicitudes HTTP entrantes, las enruta a los controladores correspondientes y devuelve las respuestas.
*   **Controladores:** Contienen la lógica de negocio para cada endpoint. Procesan los datos de la solicitud, interactúan con los modelos de datos y llaman a los servicios necesarios.
*   **Modelos (Sequelize ORM):** Definen la estructura de los datos y las relaciones entre ellos. Sequelize se utiliza para interactuar con la base de datos PostgreSQL, abstrayendo las consultas SQL directas.
*   **Validadores (express-validator):** Se utilizan para validar los datos de entrada en las solicitudes antes de que lleguen a los controladores, asegurando la integridad y el formato correcto de los datos.
*   **Middlewares:** Funciones que se ejecutan durante el ciclo de vida de la solicitud-respuesta. Se utilizan para tareas como la autenticación (JWT), autorización (verificación de permisos), logging y manejo de errores.
*   **Base de Datos (PostgreSQL):** Almacena todos los datos persistentes de la aplicación.
*   **Sistema de Ruteo:** Define cómo las URLs de la API se mapean a los controladores específicos.

**Flujo Típico de una Solicitud:**

1.  El cliente envía una solicitud HTTP a un endpoint específico de la API.
2.  Express.js recibe la solicitud.
3.  Se ejecutan middlewares globales (ej. logging, CORS).
4.  El middleware de autenticación (si el endpoint es protegido) verifica el token JWT.
5.  El middleware de autorización (si es necesario) verifica si el usuario tiene los permisos requeridos.
6.  Los validadores de `express-validator` revisan los datos de la solicitud (body, params, query). Si hay errores, se devuelve una respuesta 400.
7.  Si la validación es exitosa, la solicitud llega al controlador correspondiente.
8.  El controlador procesa la solicitud, interactúa con los modelos (Sequelize) para operaciones de base de datos.
9.  El controlador genera una respuesta (generalmente en formato JSON).
10. La respuesta se envía de vuelta al cliente.

## 3. Configuración del Entorno

Para ejecutar y desarrollar la API de SteticSoft, se requiere la siguiente configuración de entorno:

*   **Node.js:** Versión 16.x o superior.
*   **NPM (Node Package Manager):** Generalmente se instala con Node.js.
*   **PostgreSQL:** Servidor de base de datos.
*   **Git:** Para control de versiones.

**Variables de Entorno (.env):**

La configuración específica de la aplicación se maneja a través de un archivo `.env` en la raíz del proyecto. Este archivo es crucial y debe contener como mínimo las siguientes variables:

```env
# Configuración del servidor
PORT=3000 # Puerto en el que correrá la API

# Configuración de la Base de Datos (PostgreSQL)
DB_USER=usuario_db
DB_PASSWORD=contrasena_db
DB_HOST=localhost
DB_PORT=5432
DB_NAME=steticsoft_db

# Secretos para JWT
JWT_SECRET=tu_secreto_muy_largo_y_seguro_para_jwt
JWT_REFRESH_SECRET=otro_secreto_muy_largo_y_seguro_para_refresh_tokens

# Configuración de Nodemailer (para envío de correos)
MAIL_HOST=smtp.example.com
MAIL_PORT=587
MAIL_USER=tu_correo@example.com
MAIL_PASS=tu_contrasena_de_correo
MAIL_FROM='"SteticSoft" <no-reply@example.com>' # Remitente por defecto

# URL del Frontend (para correos de recuperación, etc.)
FRONTEND_URL=http://localhost:5173

# Otros
LOG_LEVEL=info # Nivel de logging (error, warn, info, http, verbose, debug, silly)
```

**Pasos para la Instalación Local:**

1.  Clonar el repositorio: `git clone <url_repositorio>`
2.  Navegar al directorio del proyecto: `cd steticsoft-api`
3.  Crear el archivo `.env` basado en `.env.example` y configurar las variables.
4.  Instalar dependencias: `npm install`
5.  Configurar la base de datos PostgreSQL y asegurarse de que esté en ejecución.
6.  Ejecutar las migraciones de Sequelize (si se utilizan para crear/actualizar el esquema): `npx sequelize-cli db:migrate`
7.  (Opcional) Ejecutar los seeders de Sequelize (para poblar la base de datos con datos iniciales): `npx sequelize-cli db:seed:all`
8.  Iniciar el servidor en modo desarrollo: `npm run dev` (generalmente usa `nodemon` para recarga automática)
9.  Iniciar el servidor en modo producción: `npm start`

## 4. Autenticación y Autorización

La API utiliza un sistema de autenticación basado en JSON Web Tokens (JWT) y un sistema de autorización basado en roles y permisos.

**Autenticación (JWT):**

1.  **Registro (`/api/auth/registrar`):** Un nuevo usuario se registra proporcionando sus datos. La contraseña se hashea (usando `bcryptjs`) antes de guardarla en la base de datos. Se le asigna un rol por defecto (ej. "Cliente").
2.  **Login (`/api/auth/login`):** El usuario envía sus credenciales (email y contraseña).
    *   El sistema verifica las credenciales contra la base de datos.
    *   Si son válidas, se generan dos tokens JWT:
        *   **Access Token:** De corta duración (ej. 15 minutos - 1 hora). Se utiliza para autorizar el acceso a los recursos protegidos de la API. Se envía en la cabecera `Authorization` como `Bearer <token>`.
        *   **Refresh Token:** De larga duración (ej. 7 días - 30 días). Se utiliza para obtener un nuevo Access Token cuando el actual expira, sin necesidad de que el usuario vuelva a ingresar sus credenciales. Se almacena de forma segura (ej. cookie HTTPOnly o localStorage seguro, dependiendo de la implementación del cliente).
    *   El Access Token se devuelve en la respuesta del login, y el Refresh Token puede devolverse en el cuerpo o en una cookie.
3.  **Acceso a Rutas Protegidas:** Para cada solicitud a una ruta protegida, el cliente debe incluir el Access Token en la cabecera `Authorization`.
    *   Un middleware (`verificarToken` en `src/middlewares/autenticacion.middleware.js`) intercepta la solicitud, extrae el token y verifica su validez (firma y expiración) usando `JWT_SECRET`.
    *   Si el token es válido, se extrae el `userId` y otros datos relevantes del payload del token y se añaden al objeto `req` (ej. `req.usuarioId`) para que los controladores puedan usarlo.
    *   Si el token es inválido o ha expirado, se devuelve un error `401 Unauthorized` o `403 Forbidden`.
4.  **Refresco de Token (`/api/auth/refresh-token` - no implementado explícitamente en el código proporcionado, pero es una práctica común):** Cuando el Access Token expira, el cliente puede enviar su Refresh Token a este endpoint.
    *   El sistema valida el Refresh Token.
    *   Si es válido, genera un nuevo Access Token y lo devuelve al cliente.
5.  **Logout (`/api/auth/logout`):** Invalida el Refresh Token del usuario (ej. eliminándolo de una lista blanca en la base de datos o caché, si se implementa de esa forma). El Access Token simplemente se deja expirar del lado del cliente.
6.  **Recuperación de Contraseña:**
    *   `/api/auth/solicitar-recuperacion`: El usuario solicita restablecer su contraseña. Se genera un token único y se envía por correo.
    *   `/api/auth/validar-token-recuperacion`: Valida el token recibido por correo.
    *   `/api/auth/resetear-contrasena`: Permite al usuario establecer una nueva contraseña si el token es válido.

**Autorización (Roles y Permisos):**

La autorización se gestiona mediante un sistema de roles y permisos asignados a los usuarios.

1.  **Modelos:**
    *   `Rol`: Define los roles disponibles en el sistema (ej. "Administrador", "Empleado", "Cliente").
    *   `Permiso`: Define las acciones específicas que se pueden realizar (ej. "GESTIONAR_USUARIOS", "VER_PRODUCTOS", "CREAR_CITA").
    *   `RolPermiso` (tabla intermedia): Asocia permisos a roles. Un rol puede tener múltiples permisos.
    *   `Usuario`: Cada usuario tiene asignado un `rolId`.

2.  **Middleware de Autorización (`verificarPermisos` en `src/middlewares/autorizacion.middleware.js`):**
    *   Este middleware se aplica a las rutas que requieren permisos específicos.
    *   Recibe como argumento una lista de permisos necesarios para acceder al recurso.
    *   Obtiene el `rolId` del usuario (inyectado por el middleware de autenticación).
    *   Consulta la base de datos (a través de `RolPermiso` y `Permiso`) para verificar si el rol del usuario tiene *alguno* de los permisos requeridos.
    *   Si el usuario tiene al menos uno de los permisos necesarios, se permite el acceso (`next()`).
    *   Si no tiene los permisos, se devuelve un error `403 Forbidden`.

**Ejemplo de Protección de Ruta:**

```javascript
// src/routes/usuarios.routes.js
import { Router }
from 'express';
import { verificarToken } from '../middlewares/autenticacion.middleware.js';
import { verificarPermisos } from '../middlewares/autorizacion.middleware.js';
import { PERMISOS } from '../config/constantes.config.js';
import { obtenerUsuarios, crearUsuario } from '../controllers/usuario.controller.js';

const router = Router();

router.get('/',
    verificarToken,
    verificarPermisos([PERMISOS.MODULO_USUARIOS_GESTIONAR, PERMISOS.MODULO_USUARIOS_VER]), // Requiere uno de estos permisos
    obtenerUsuarios
);

router.post('/',
    verificarToken,
    verificarPermisos([PERMISOS.MODULO_USUARIOS_GESTIONAR, PERMISOS.MODULO_USUARIOS_CREAR]), // Requiere uno de estos permisos
    // ... validadores ...
    crearUsuario
);

export default router;
```

En este ejemplo, para acceder a `GET /api/usuarios`, el usuario debe estar autenticado (`verificarToken`) y su rol debe tener el permiso `MODULO_USUARIOS_GESTIONAR` o `MODULO_USUARIOS_VER` (`verificarPermisos`).

## 5. Manejo de Errores

La API implementa un sistema centralizado de manejo de errores para asegurar respuestas consistentes y útiles.

**Tipos de Errores Manejados:**

1.  **Errores de Validación (`express-validator`):**
    *   Si los datos de entrada no cumplen con las reglas de validación definidas, `express-validator` genera una lista de errores.
    *   Un middleware (o lógica dentro de los controladores/rutas) intercepta estos errores y devuelve una respuesta `400 Bad Request` con un array de los errores específicos.
    ```json
    {
        "errors": [
            {
                "type": "field",
                "value": "email_invalido",
                "msg": "El correo electrónico no es válido.",
                "path": "email",
                "location": "body"
            }
        ]
    }
    ```

2.  **Errores de Autenticación/Autorización:**
    *   Token inválido/expirado: `401 Unauthorized`.
    *   Permisos insuficientes: `403 Forbidden`.
    *   Estos son manejados por los middlewares `verificarToken` y `verificarPermisos`.

3.  **Errores de Lógica de Negocio (Errores Personalizados):**
    *   Se utilizan clases de error personalizadas (ej. `NotFoundError`, `ValidationError`, `ForbiddenError` que heredan de una clase base `HttpError`) para representar errores específicos de la aplicación.
    *   Los controladores y servicios lanzan estos errores cuando se encuentran condiciones anómalas (ej. recurso no encontrado, conflicto de datos).
    *   Ejemplo: `throw new NotFoundError('Usuario no encontrado');`

4.  **Errores Inesperados del Servidor (Errores 500):**
    *   Errores no capturados explícitamente (ej. fallos en la base de datos, errores de programación).
    *   Un middleware de manejo de errores global (generalmente definido al final de la cadena de middlewares en `app.js` o `index.js`) captura cualquier error que no haya sido manejado previamente.
    *   Este middleware registra el error (para depuración) y devuelve una respuesta genérica `500 Internal Server Error`. En entornos de desarrollo, puede devolver más detalles, pero en producción, se debe evitar exponer información sensible.

**Middleware Global de Manejo de Errores:**

```javascript
// Ejemplo conceptual (puede estar en src/middlewares/errores.middleware.js o app.js)
app.use((err, req, res, next) => {
    console.error(err); // Loguear el error completo para depuración

    const statusCode = err.statusCode || 500;
    const message = err.statusCode ? err.message : 'Error interno del servidor'; // No exponer detalles de errores 500 en producción

    res.status(statusCode).json({
        status: 'error',
        statusCode: statusCode,
        message: message,
        // ...(process.env.NODE_ENV === 'development' ? { stack: err.stack } : {}) // Stack trace solo en desarrollo
    });
});
```

**Prácticas Recomendadas:**

*   **Ser Específico:** Devolver códigos de estado HTTP precisos.
*   **Mensajes Claros:** Proporcionar mensajes de error que sean comprensibles para el cliente (y potencialmente para el usuario final, si la API es consumida directamente por un frontend).
*   **No Exponer Información Sensible:** Evitar filtrar detalles internos del sistema o stack traces en producción.
*   **Logging:** Registrar errores detalladamente en el servidor para facilitar la depuración.

## 6. Validación de Datos

La validación de datos es un aspecto crítico para mantener la integridad de los datos y la seguridad de la API. Se utiliza `express-validator` para este propósito.

**Cómo Funciona:**

1.  **Definición de Reglas:** Las reglas de validación se definen como un array de middlewares que se aplican a las rutas antes de que la solicitud llegue al controlador.
2.  **Ubicación de los Validadores:** Pueden estar directamente en los archivos de rutas o en archivos separados (ej. `src/validators/usuario.validator.js`) para mayor organización.
3.  **Cadenas de Validación:** `express-validator` proporciona una API fluida para encadenar múltiples validaciones y sanitizaciones en un campo específico.
    *   **Validadores Comunes:** `notEmpty()`, `isEmail()`, `isLength()`, `isNumeric()`, `isDate()`, `isIn()`, `custom()`.
    *   **Sanitizadores Comunes:** `trim()`, `escape()`, `toLowerCase()`, `toDate()`.
4.  **Manejo de Resultados de Validación:**
    *   La función `validationResult(req)` de `express-validator` se usa dentro de la ruta o un middleware posterior para recopilar cualquier error de validación.
    *   Si `validationResult(req).isEmpty()` es `false`, significa que hay errores. Se devuelve una respuesta `400 Bad Request` con los detalles de los errores.

**Ejemplo de Validador (`src/validators/auth.validator.js`):**

```javascript
// src/validators/auth.validator.js
import { body } from 'express-validator';
import { manejarResultadosValidacion } from '../middlewares/validacion.middleware.js'; // Middleware para centralizar el manejo de resultados

export const loginValidator = [
    body('email')
        .trim()
        .notEmpty().withMessage('El correo electrónico es obligatorio.')
        .isEmail().withMessage('El formato del correo electrónico no es válido.'),
    body('password')
        .notEmpty().withMessage('La contraseña es obligatoria.')
        .isLength({ min: 6 }).withMessage('La contraseña debe tener al menos 6 caracteres.'),
    manejarResultadosValidacion // Middleware que comprueba validationResult y responde si hay errores
];

export const registroValidator = [
    body('nombreCompleto')
        .trim()
        .notEmpty().withMessage('El nombre completo es obligatorio.')
        .isLength({ min: 3, max: 100 }).withMessage('El nombre completo debe tener entre 3 y 100 caracteres.'),
    body('email')
        .trim()
        .notEmpty().withMessage('El correo electrónico es obligatorio.')
        .isEmail().withMessage('El formato del correo electrónico no es válido.')
        // Aquí podría ir una validación custom para verificar si el email ya existe
        // .custom(async (value) => { ... }),
    body('password')
        .notEmpty().withMessage('La contraseña es obligatoria.')
        .isLength({ min: 8 }).withMessage('La contraseña debe tener al menos 8 caracteres.')
        .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/)
        .withMessage('La contraseña debe contener al menos una mayúscula, una minúscula, un número y un carácter especial.'),
    body('confirmarPassword')
        .notEmpty().withMessage('La confirmación de contraseña es obligatoria.')
        .custom((value, { req }) => {
            if (value !== req.body.password) {
                throw new Error('Las contraseñas no coinciden.');
            }
            return true;
        }),
    body('rolId') // Asumiendo que el rol se puede especificar o se asigna uno por defecto
        .optional()
        .isInt({ gt: 0 }).withMessage('El ID del rol no es válido.'),
    manejarResultadosValidacion
];
```

**Middleware `manejarResultadosValidacion` (`src/middlewares/validacion.middleware.js`):**

```javascript
// src/middlewares/validacion.middleware.js
import { validationResult } from 'express-validator';

export const manejarResultadosValidacion = (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }
    next();
};
```

**Uso en Rutas:**

```javascript
// src/routes/auth.routes.js
import { Router } from 'express';
import { loginValidator, registroValidator } from '../validators/auth.validator.js';
import { login, registrar } from '../controllers/auth.controller.js';

const router = Router();

router.post('/login', loginValidator, login);
router.post('/registrar', registroValidator, registrar);

export default router;
```

Este enfoque asegura que los datos inválidos sean rechazados tempranamente, protegiendo la lógica de negocio y la base de datos de información incorrecta o maliciosa.

## 7. Base de Datos (Resumen Inicial)

La API utiliza **PostgreSQL** como sistema de gestión de bases de datos relacional (RDBMS) y **Sequelize** como ORM (Object-Relational Mapper) para interactuar con ella.

**PostgreSQL:**

*   Es una base de datos SQL robusta, de código abierto y altamente escalable.
*   Ofrece características avanzadas como transacciones ACID, tipos de datos complejos, indexación avanzada y extensibilidad.

**Sequelize ORM:**

*   **Abstracción:** Permite a los desarrolladores trabajar con objetos y métodos de JavaScript en lugar de escribir consultas SQL manualmente. Sequelize traduce estas operaciones a SQL.
*   **Modelos:** Cada tabla en la base de datos se representa como un "Modelo" en Sequelize (ej. `Usuario`, `Producto`, `Cita`). Los modelos definen el esquema de la tabla (columnas, tipos de datos, restricciones) y las asociaciones entre tablas.
    *   Los modelos se definen en la carpeta `src/models/`. Cada archivo (ej. `usuario.model.js`) define un modelo.
    *   El archivo `src/models/index.js` (o similar, a veces llamado `database.js` o `db.js`) es responsable de inicializar Sequelize, cargar todos los modelos, definir las asociaciones entre ellos y sincronizar los modelos con la base de datos (opcionalmente).
*   **Asociaciones:** Sequelize permite definir fácilmente relaciones entre modelos:
    *   `hasOne` (uno a uno)
    *   `belongsTo` (uno a uno inverso)
    *   `hasMany` (uno a muchos)
    *   `belongsToMany` (muchos a muchos, a través de una tabla intermedia)
    *   Ejemplo: Un `Usuario` puede tener un `Rol` (`belongsTo`), y un `Rol` puede tener muchos `Usuarios` (`hasMany`). Un `Producto` `belongsToMany` `Categorias` a través de una tabla `ProductoCategoria`.
*   **Consultas:** Proporciona métodos para realizar operaciones CRUD (Crear, Leer, Actualizar, Eliminar) y consultas complejas.
    *   `Model.create()`
    *   `Model.findAll()`, `Model.findOne()`, `Model.findByPk()`
    *   `instance.update()`
    *   `instance.destroy()`
    *   Opciones de consulta: `where`, `attributes`, `include` (para eager loading de asociaciones), `order`, `limit`, `offset`.
*   **Migraciones:** Sequelize CLI ofrece un sistema de migraciones para gestionar cambios en el esquema de la base de datos de forma versionada. Esto es crucial para entornos de producción y trabajo en equipo.
    *   Las migraciones se almacenan en la carpeta `src/migrations/`.
    *   Comandos: `npx sequelize-cli db:migrate`, `npx sequelize-cli migration:generate --name <nombre_migracion>`.
*   **Seeders:** Permiten poblar la base de datos con datos iniciales o de prueba.
    *   Los seeders se almacenan en la carpeta `src/seeders/`.
    *   Comandos: `npx sequelize-cli db:seed:all`, `npx sequelize-cli seed:generate --name <nombre_seeder>`.

**Configuración de Sequelize:**

La configuración de la conexión a la base de datos para Sequelize se encuentra típicamente en un archivo `src/config/config.json` (usado por Sequelize CLI) y también se usa para instanciar Sequelize en el código (ej. `src/models/index.js`), a menudo leyendo las credenciales desde variables de entorno.

**Ejemplo de Definición de Modelo (Conceptual):**

```javascript
// src/models/usuario.model.js
import { DataTypes } from 'sequelize';

export default (sequelize) => {
    const Usuario = sequelize.define('Usuario', {
        id: {
            type: DataTypes.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        nombreCompleto: {
            type: DataTypes.STRING,
            allowNull: false
        },
        email: {
            type: DataTypes.STRING,
            allowNull: false,
            unique: true,
            validate: {
                isEmail: true
            }
        },
        password: {
            type: DataTypes.STRING,
            allowNull: false
        },
        rolId: { // Clave foránea para la relación con Rol
            type: DataTypes.INTEGER,
            references: {
                model: 'Roles', // Nombre de la tabla de Roles
                key: 'id'
            }
        },
        // ... otros campos y timestamps (createdAt, updatedAt)
    }, {
        tableName: 'Usuarios', // Nombre explícito de la tabla
        timestamps: true // Habilita createdAt y updatedAt automáticamente
    });

    Usuario.associate = (models) => {
        Usuario.belongsTo(models.Rol, { foreignKey: 'rolId', as: 'rol' });
        // Otras asociaciones (ej. un Usuario puede tener muchas Citas como Cliente o como Empleado)
        Usuario.hasMany(models.Cita, { foreignKey: 'clienteId', as: 'citasCliente' });
        Usuario.hasMany(models.Cita, { foreignKey: 'empleadoId', as: 'citasEmpleado' });
    };

    return Usuario;
};
```
La estructura detallada de cada modelo y sus relaciones se documentará en la sección de "Módulos Principales".

## 8. Consideraciones Adicionales

Además de las funcionalidades principales, la API contempla otros aspectos importantes:

**Tareas Programadas (Cron Jobs):**

*   Aunque no se detalla una implementación específica en el código fuente analizado, una API de esta naturaleza a menudo requiere tareas programadas para mantenimiento, recordatorios, o procesos batch.
*   **Posibles Usos:**
    *   Envío de recordatorios de citas por correo electrónico (ej. 24 horas antes).
    *   Limpieza de tokens de recuperación expirados.
    *   Generación de informes periódicos.
    *   Actualización de estados (ej. marcar citas como "Completada" después de la fecha/hora).
*   **Implementación Común:** Se podría utilizar una librería como `node-cron` para definir y ejecutar estas tareas dentro de la misma aplicación Node.js. Para sistemas más complejos o distribuidos, se podrían usar servicios externos de cron o colas de mensajes.

**Envío de Correos Electrónicos:**

*   La API utiliza **Nodemailer** para el envío de correos transaccionales.
*   **Configuración:** Las credenciales del servidor SMTP y las opciones de correo se configuran mediante variables de entorno (ver `MAIL_HOST`, `MAIL_USER`, etc. en la sección "Configuración del Entorno").
*   **Casos de Uso Implementados:**
    *   Confirmación de registro (si se implementara).
    *   Notificación de solicitud de recuperación de contraseña (envío de token).
    *   Confirmación de contraseña reseteada.
    *   Notificación de creación de cita (para cliente y/o empleado).
    *   Notificación de cancelación/reprogramación de cita.
*   **Plantillas de Correo:** El código utiliza plantillas HTML simples (ej. `src/utils/templates/emailRecuperacion.js`) para formatear los correos. Para aplicaciones más grandes, se podrían usar motores de plantillas como Handlebars o EJS.
*   **Servicio de Correo (`src/services/email.service.js`):** Abstrae la lógica de Nodemailer, facilitando el envío de correos desde diferentes partes de la aplicación.

**Logging:**

*   Se utiliza una librería de logging (implícitamente, podría ser `Winston`, `Pino` o incluso `console.log` enriquecido en un sistema más simple) para registrar eventos importantes, errores y actividad de la API.
*   El nivel de logging (`LOG_LEVEL`) se puede configurar mediante variables de entorno.
*   Un buen logging es esencial para la depuración, el monitoreo y la auditoría de la API.

**Seguridad (Adicional a AuthN/AuthZ):**

*   **CORS (Cross-Origin Resource Sharing):** Configurado para permitir solicitudes desde dominios específicos (ej. el frontend). Se usa el middleware `cors`.
*   **Protección contra XSS (Cross-Site Scripting):** Aunque `express-validator` ofrece sanitizadores, es importante ser consciente de dónde se reflejan los datos del usuario en las respuestas.
*   **Protección contra CSRF (Cross-Site Request Forgery):** Menos relevante para APIs que usan tokens Bearer, pero importante si se usan sesiones basadas en cookies.
*   **Rate Limiting:** No implementado explícitamente en el código analizado, pero es una buena práctica para prevenir abusos (ej. usando `express-rate-limit`).
*   **Helmet:** Middleware que ayuda a proteger la aplicación configurando diversas cabeceras HTTP relacionadas con la seguridad.
*   **Actualización de Dependencias:** Mantener las dependencias actualizadas es crucial para mitigar vulnerabilidades conocidas.

**Documentación de API (Swagger/OpenAPI):**

*   No se observa una implementación de Swagger/OpenAPI en el código, pero sería una adición valiosa para generar documentación interactiva de la API y facilitar su consumo por parte de los clientes.
*   Herramientas como `swagger-jsdoc` y `swagger-ui-express` pueden integrarse fácilmente en aplicaciones Express.js.
